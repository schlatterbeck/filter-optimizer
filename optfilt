#!/usr/bin/python3

from __future__ import print_function
from argparse   import ArgumentParser
from scipy      import signal
from bisect     import bisect
import pga
import sys
import numpy as np
from rsclib.autosuper import autosuper
from filterplot import Filter_Bound, Filter_Bounds

class Filter_Opt (pga.PGA, autosuper) :
    """ Optimize a filter with differential evolution
    """

    def __init__ (self, args) :
        self.neval  = 0
        self.args   = args
        self.npoles = 4
        self.nzeros = 5
        # parameters in the form radius, angle
        # first the zeros then the poles
        # All angles in the range   [0, 0.5]
        # zeros radius in the range [0, 5]
        # poles radius in the range [0, 0.999]
        ini = []
        for k in range (self.nzeros) :
            ini.append ((0, 5))
            ini.append ((0, 0.5))
        for k in range (self.npoles) :
            ini.append ((0, 0.999))
            ini.append ((0, 0.5))
        de_cross_type = pga.PGA_DE_CROSSOVER_BIN
        if self.args.use_exponential_crossover :
            de_cross_type = pga.PGA_DE_CROSSOVER_EXP
        variant = getattr (pga, 'PGA_DE_VARIANT_' \
                + self.args.de_variant.upper ())
        f = self.args.scale_factor - (self.args.popsize * 0.0005)
        super (self.__class__, self).__init__ \
            ( float, 2 * (self.npoles + self.nzeros)
            , maximize                    = False
            , pop_size                    = self.args.popsize
            , num_replace                 = self.args.popsize
            , print_options               = [pga.PGA_REPORT_STRING]
            #, print_frequency             = 200
            , init                        = ini
            , select_type                 = pga.PGA_SELECT_LINEAR
            , pop_replace_type            = pga.PGA_POPREPL_PAIRWISE_BEST
            , mutation_bounce_back        = True
            , mutation_only               = True
            , mutation_type               = pga.PGA_MUTATION_DE
            , DE_variant                  = variant
            , DE_crossover_prob           = 1.0
            , DE_jitter                   = 0.001
            , DE_scale_factor             = f
            , DE_crossover_type           = de_cross_type
            , random_seed                 = args.random_seed
            )
        self.x  = []
        self.yu = []
        self.yl = []
        self.udb = Filter_Bounds \
            ( Filter_Bound (0.0,     0.04938, 0.01,  0.025)
            , Filter_Bound (0.04938, 0.2716,  0.025, 0.025, 17)
            , Filter_Bound (0.2716,  0.3334,  0.05,  0.05, 11)
            , Filter_Bound (0.3334,  0.395, -12,   -12)
            , Filter_Bound (0.395,   0.5,   -40,   -40, 17)
            )
        self.ldb = Filter_Bounds \
            ( Filter_Bound (0.0,     0.04938, -0.01,  -0.025)
            , Filter_Bound (0.04938, 0.2716,  -0.025, -0.025, 17)
            , Filter_Bound (0.2716,  0.284,   -0.05,  -0.05)
            , is_lower = True
            )
        self.dbx = list (sorted (set (np.concatenate
            ((self.ldb.x, self.udb.x)))))
        self.udelay = Filter_Bounds \
            (Filter_Bound (0.0, 0.284,  0.10125,  0.30375, 17))
        self.ldelay = Filter_Bounds \
            ( Filter_Bound (0.0, 0.284, -0.10125, -0.30375, 17)
            , is_lower = True
            )
        self.delay_x = list (sorted (set (np.concatenate
            ((self.udelay.x, self.ldelay.x)))))
        self.fir  = \
            [-0.033271, -0.019816, 0.169865, 0.415454
            , 0.415454, 0.169865, -0.019816, -0.033271
            ]
        fir_w, self.fir_h = signal.freqz (self.fir, [1.0], self.dbx)
        self.a0 = 0.00390625
    # end def __init__

    def phenotype (self, p, pop) :
        def ga (i) :
            return self.get_allele (p, pop, i)
        # pole offset in gene
        po = 2 * self.nzeros
        zeros = [ga (2*k)    * np.e ** (2j * np.pi * ga (2*k+1))
                 for k in range (self.nzeros)]
        poles = [ga (2*k+po) * np.e ** (2j * np.pi * ga (2*k+po+1))
                 for k in range (self.npoles)]
        self.update_conjugate_complex (zeros)
        self.update_conjugate_complex (poles)
        (b, a)  = signal.zpk2tf (zeros, poles, self.a0)
        return (zeros, poles, b, a)
    # end def phenotype

    def evaluate (self, p, pop) :
        self.neval += 1
        zeros, poles, b, a = self.phenotype (p, pop)
        wgd, gd = signal.group_delay ((b, a), self.delay_x)
        w, h    = signal.freqz       (b, a, self.dbx)
        hf      = self.fir_h * h
        db      = 20 * np.log10 (abs (hf))
        dbdict  = dict ((x, y) for x, y in zip (self.dbx, db))
        dldict  = dict ((x, y) for x, y in zip (self.delay_x, gd))

        ev = 0.0
        for xb, yb in self.udb :
            if dbdict [xb] > yb :
                ev += (dbdict [xb] - yb) ** 2
        for xb, yb in self.ldb :
            if dbdict [xb] < yb :
                ev += (dbdict [xb] - yb) ** 2
        delaydelta = None
        # Shift the curve so that it touches the upper delay delta
        for xb, yb in self.udelay :
            delta = dldict [xb] - (yb / 2 * np.pi)
            if delaydelta is None or delta > delaydelta :
                delaydelta = delta
        # Check where the curve underflows the lower delay delta
        for xb, yb in self.ldelay :
            d = yb / (2 * np.pi)
            if dldict [xb] - delaydelta < d :
                ev += (dldict [xb] - delaydelta - d) ** 2
        return ev
    # end def evaluate

    def stop_cond (self) :
        best = self.get_best_index (pga.PGA_OLDPOP)
        if self.get_evaluation (best, pga.PGA_OLDPOP) == 0 :
            return True
        return self.check_stopping_conditions ()
    # end def stop_cond

    def update_conjugate_complex (self, nums) :
        """ Modify nums in-place to add conjugate complex numbers """
        n2 = [k.conjugate () for k in nums if k.imag]
        nums.extend (n2)
    # end def update_conjugate_complex

    def pre_eval (self, pop) :
        if not self.args.sort_population :
            return
        ga  = self.get_allele
        # Unpack gene into pairs (angle, radius)
        for p in range (self.pop_size) :
            zeros = \
                [( ga (p, pop, 2*i + 1)
                 , ga (p, pop, 2*i)
                 )
                 for i in range (self.nzeros)
                ]
            poles = \
                [( ga (p, pop, 2*i + 2*self.nzeros + 1)
                 , ga (p, pop, 2*i + 2*self.nzeros)
                 )
                 for i in range (self.npoles)
                ]
            # Sort by angle/radius
            zeros = list (sorted (zeros))
            poles = list (sorted (poles))
            # re-pack into gene
            for i in range (self.nzeros) :
                self.set_allele (p, pop, 2*i,   zeros [i][1])
                self.set_allele (p, pop, 2*i+1, zeros [i][0])
            for i in range (self.npoles) :
                self.set_allele (p, pop, 2*i + 2*self.nzeros,   poles [i][1])
                self.set_allele (p, pop, 2*i + 2*self.nzeros+1, poles [i][0])
    # end def pre_eval

    def _print (self, f, p, pop, n, offset) :
        for k in range (n) :
            e = ', '
            if k == n - 1 :
                e = '\n'
            a = self.get_allele (p, pop, 2*k+offset)
            print ("%1.8f" % a, file = f, end = e)
    # end def _print

    def print_string (self, f, p, pop) :
        #zeros, poles, b, a = self.phenotype (p, pop)
        print ("Iter: %s Evals: %s" % (self.GA_iter, self.neval), file = f)
        #print ('params.append \\', file = f)
        #print (" ([ ", file = f, end = '')
        #self._print (f, p, pop, self.nzeros, 0)
        #print (" ,  ", file = f, end = '')
        #self._print (f, p, pop, self.nzeros, 1)
        #print (" ,  ", file = f, end = '')
        #self._print (f, p, pop, self.npoles, 2 * self.nzeros)
        #print (" ,  ", file = f, end = '')
        #self._print (f, p, pop, self.npoles, 2 * self.nzeros + 1)
        #print (" ])", file = f)
        f.flush ()
        self.__super.print_string (f, p, pop)
        f.flush ()
    # end def print_string

# end class Filter_Opt

def main () :
    cmd = ArgumentParser ()
    cmd.add_argument \
        ( '-d', '--de-variant'
        , help    = "Variant of DE algorithm, one of rand/best default=%(default)s"
        , default = 'best'
        )
    cmd.add_argument \
        ( '-e', '--use-exponential-crossover'
        , help    = "Use exp crossover (instead of bin)"
        , default = False
        , action  = 'store_true'
        )
    cmd.add_argument \
        ( '-F', '--scale-factor'
        , help    = "Base DE scale factor F, default=%(default)s "
                    "(popsize-dependent part is subtracted)"
        , default = 0.85
        , type    = float
        )
    cmd.add_argument \
        ( '-p', '--popsize'
        , type    = int
        , help    = "Population size, default=%(default)s"
        , default = 300
        )
    cmd.add_argument \
        ( '-R', '--random-seed'
        , type    = int
        , help    = "Random number seed, default=%(default)s"
        , default = 42
        )
    cmd.add_argument \
        ( '-s', '--sort-population'
        , help    = "Sort population by angle/radius"
        , default = False
        , action  = 'store_true'
        )
    args = cmd.parse_args ()
    pg = Filter_Opt (args)
    pg.run ()
# end def main

if __name__ == '__main__' :
    main ()
